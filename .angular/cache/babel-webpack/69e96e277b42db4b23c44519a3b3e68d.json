{"ast":null,"code":"import _asyncToGenerator from \"F:/Mockup3/FontEnd/mockup1_team03_frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ComponentHarness, HarnessPredicate } from '@angular/cdk/testing';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass _MatRadioGroupHarnessBase extends ComponentHarness {\n  /** Gets the name of the radio-group. */\n  getName() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const hostName = yield _this._getGroupNameFromHost(); // It's not possible to always determine the \"name\" of a radio-group by reading\n      // the attribute. This is because the radio-group does not set the \"name\" as an\n      // element attribute if the \"name\" value is set through a binding.\n\n      if (hostName !== null) {\n        return hostName;\n      } // In case we couldn't determine the \"name\" of a radio-group by reading the\n      // \"name\" attribute, we try to determine the \"name\" of the group by going\n      // through all radio buttons.\n\n\n      const radioNames = yield _this._getNamesFromRadioButtons();\n\n      if (!radioNames.length) {\n        return null;\n      }\n\n      if (!_this._checkRadioNamesInGroupEqual(radioNames)) {\n        throw Error('Radio buttons in radio-group have mismatching names.');\n      }\n\n      return radioNames[0];\n    })();\n  }\n  /** Gets the id of the radio-group. */\n\n\n  getId() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this2.host()).getProperty('id');\n    })();\n  }\n  /** Gets the checked radio-button in a radio-group. */\n\n\n  getCheckedRadioButton() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      for (let radioButton of yield _this3.getRadioButtons()) {\n        if (yield radioButton.isChecked()) {\n          return radioButton;\n        }\n      }\n\n      return null;\n    })();\n  }\n  /** Gets the checked value of the radio-group. */\n\n\n  getCheckedValue() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const checkedRadio = yield _this4.getCheckedRadioButton();\n\n      if (!checkedRadio) {\n        return null;\n      }\n\n      return checkedRadio.getValue();\n    })();\n  }\n  /**\n   * Gets a list of radio buttons which are part of the radio-group.\n   * @param filter Optionally filters which radio buttons are included.\n   */\n\n\n  getRadioButtons(filter) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this5.locatorForAll(_this5._buttonClass.with(filter))();\n    })();\n  }\n  /**\n   * Checks a radio button in this group.\n   * @param filter An optional filter to apply to the child radio buttons. The first tab matching\n   *     the filter will be selected.\n   */\n\n\n  checkRadioButton(filter) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const radioButtons = yield _this6.getRadioButtons(filter);\n\n      if (!radioButtons.length) {\n        throw Error(`Could not find radio button matching ${JSON.stringify(filter)}`);\n      }\n\n      return radioButtons[0].check();\n    })();\n  }\n  /** Gets the name attribute of the host element. */\n\n\n  _getGroupNameFromHost() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this7.host()).getAttribute('name');\n    })();\n  }\n  /** Gets a list of the name attributes of all child radio buttons. */\n\n\n  _getNamesFromRadioButtons() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const groupNames = [];\n\n      for (let radio of yield _this8.getRadioButtons()) {\n        const radioName = yield radio.getName();\n\n        if (radioName !== null) {\n          groupNames.push(radioName);\n        }\n      }\n\n      return groupNames;\n    })();\n  }\n  /** Checks if the specified radio names are all equal. */\n\n\n  _checkRadioNamesInGroupEqual(radioNames) {\n    let groupName = null;\n\n    for (let radioName of radioNames) {\n      if (groupName === null) {\n        groupName = radioName;\n      } else if (groupName !== radioName) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Checks if a radio-group harness has the given name. Throws if a radio-group with\n   * matching name could be found but has mismatching radio-button names.\n   */\n\n\n  static _checkRadioGroupName(harness, name) {\n    return _asyncToGenerator(function* () {\n      // Check if there is a radio-group which has the \"name\" attribute set\n      // to the expected group name. It's not possible to always determine\n      // the \"name\" of a radio-group by reading the attribute. This is because\n      // the radio-group does not set the \"name\" as an element attribute if the\n      // \"name\" value is set through a binding.\n      if ((yield harness._getGroupNameFromHost()) === name) {\n        return true;\n      } // Check if there is a group with radio-buttons that all have the same\n      // expected name. This implies that the group has the given name. It's\n      // not possible to always determine the name of a radio-group through\n      // the attribute because there is\n\n\n      const radioNames = yield harness._getNamesFromRadioButtons();\n\n      if (radioNames.indexOf(name) === -1) {\n        return false;\n      }\n\n      if (!harness._checkRadioNamesInGroupEqual(radioNames)) {\n        throw Error(`The locator found a radio-group with name \"${name}\", but some ` + `radio-button's within the group have mismatching names, which is invalid.`);\n      }\n\n      return true;\n    })();\n  }\n\n}\n/** Harness for interacting with a standard mat-radio-group in tests. */\n\n\nclass MatRadioGroupHarness extends _MatRadioGroupHarnessBase {\n  constructor() {\n    super(...arguments);\n    this._buttonClass = MatRadioButtonHarness;\n  }\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatRadioGroupHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which radio group instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n\n\n  static with(options = {}) {\n    return new HarnessPredicate(MatRadioGroupHarness, options).addOption('name', options.name, this._checkRadioGroupName);\n  }\n\n}\n/** The selector for the host element of a `MatRadioGroup` instance. */\n\n\nMatRadioGroupHarness.hostSelector = '.mat-radio-group';\n\nclass _MatRadioButtonHarnessBase extends ComponentHarness {\n  constructor() {\n    super(...arguments);\n    this._input = this.locatorFor('input');\n  }\n  /** Whether the radio-button is checked. */\n\n\n  isChecked() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const checked = (yield _this9._input()).getProperty('checked');\n      return coerceBooleanProperty(yield checked);\n    })();\n  }\n  /** Whether the radio-button is disabled. */\n\n\n  isDisabled() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const disabled = (yield _this10._input()).getAttribute('disabled');\n      return coerceBooleanProperty(yield disabled);\n    })();\n  }\n  /** Whether the radio-button is required. */\n\n\n  isRequired() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      const required = (yield _this11._input()).getAttribute('required');\n      return coerceBooleanProperty(yield required);\n    })();\n  }\n  /** Gets the radio-button's name. */\n\n\n  getName() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this12._input()).getAttribute('name');\n    })();\n  }\n  /** Gets the radio-button's id. */\n\n\n  getId() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this13.host()).getProperty('id');\n    })();\n  }\n  /**\n   * Gets the value of the radio-button. The radio-button value will be converted to a string.\n   *\n   * Note: This means that for radio-button's with an object as a value `[object Object]` is\n   * intentionally returned.\n   */\n\n\n  getValue() {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this14._input()).getProperty('value');\n    })();\n  }\n  /** Gets the radio-button's label text. */\n\n\n  getLabelText() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this15._textLabel()).text();\n    })();\n  }\n  /** Focuses the radio-button. */\n\n\n  focus() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this16._input()).focus();\n    })();\n  }\n  /** Blurs the radio-button. */\n\n\n  blur() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this17._input()).blur();\n    })();\n  }\n  /** Whether the radio-button is focused. */\n\n\n  isFocused() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this18._input()).isFocused();\n    })();\n  }\n  /**\n   * Puts the radio-button in a checked state by clicking it if it is currently unchecked,\n   * or doing nothing if it is already checked.\n   */\n\n\n  check() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this19.isChecked())) {\n        return (yield _this19._clickLabel()).click();\n      }\n    })();\n  }\n\n}\n/** Harness for interacting with a standard mat-radio-button in tests. */\n\n\nclass MatRadioButtonHarness extends _MatRadioButtonHarnessBase {\n  constructor() {\n    super(...arguments);\n    this._textLabel = this.locatorFor('.mat-radio-label-content');\n    this._clickLabel = this.locatorFor('.mat-radio-label');\n  }\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatRadioButtonHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which radio button instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n\n\n  static with(options = {}) {\n    return new HarnessPredicate(MatRadioButtonHarness, options).addOption('label', options.label, (harness, label) => HarnessPredicate.stringMatches(harness.getLabelText(), label)).addOption('name', options.name, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (harness, name) {\n        return (yield harness.getName()) === name;\n      });\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n}\n/** The selector for the host element of a `MatRadioButton` instance. */\n\n\nMatRadioButtonHarness.hostSelector = '.mat-radio-button';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatRadioButtonHarness, MatRadioGroupHarness, _MatRadioButtonHarnessBase, _MatRadioGroupHarnessBase };","map":{"version":3,"sources":["F:/Mockup3/FontEnd/mockup1_team03_frontend/node_modules/@angular/material/fesm2020/radio/testing.mjs"],"names":["coerceBooleanProperty","ComponentHarness","HarnessPredicate","_MatRadioGroupHarnessBase","getName","hostName","_getGroupNameFromHost","radioNames","_getNamesFromRadioButtons","length","_checkRadioNamesInGroupEqual","Error","getId","host","getProperty","getCheckedRadioButton","radioButton","getRadioButtons","isChecked","getCheckedValue","checkedRadio","getValue","filter","locatorForAll","_buttonClass","with","checkRadioButton","radioButtons","JSON","stringify","check","getAttribute","groupNames","radio","radioName","push","groupName","_checkRadioGroupName","harness","name","indexOf","MatRadioGroupHarness","constructor","arguments","MatRadioButtonHarness","options","addOption","hostSelector","_MatRadioButtonHarnessBase","_input","locatorFor","checked","isDisabled","disabled","isRequired","required","getLabelText","_textLabel","text","focus","blur","isFocused","_clickLabel","click","label","stringMatches"],"mappings":"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","sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ComponentHarness, HarnessPredicate } from '@angular/cdk/testing';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass _MatRadioGroupHarnessBase extends ComponentHarness {\n    /** Gets the name of the radio-group. */\n    async getName() {\n        const hostName = await this._getGroupNameFromHost();\n        // It's not possible to always determine the \"name\" of a radio-group by reading\n        // the attribute. This is because the radio-group does not set the \"name\" as an\n        // element attribute if the \"name\" value is set through a binding.\n        if (hostName !== null) {\n            return hostName;\n        }\n        // In case we couldn't determine the \"name\" of a radio-group by reading the\n        // \"name\" attribute, we try to determine the \"name\" of the group by going\n        // through all radio buttons.\n        const radioNames = await this._getNamesFromRadioButtons();\n        if (!radioNames.length) {\n            return null;\n        }\n        if (!this._checkRadioNamesInGroupEqual(radioNames)) {\n            throw Error('Radio buttons in radio-group have mismatching names.');\n        }\n        return radioNames[0];\n    }\n    /** Gets the id of the radio-group. */\n    async getId() {\n        return (await this.host()).getProperty('id');\n    }\n    /** Gets the checked radio-button in a radio-group. */\n    async getCheckedRadioButton() {\n        for (let radioButton of await this.getRadioButtons()) {\n            if (await radioButton.isChecked()) {\n                return radioButton;\n            }\n        }\n        return null;\n    }\n    /** Gets the checked value of the radio-group. */\n    async getCheckedValue() {\n        const checkedRadio = await this.getCheckedRadioButton();\n        if (!checkedRadio) {\n            return null;\n        }\n        return checkedRadio.getValue();\n    }\n    /**\n     * Gets a list of radio buttons which are part of the radio-group.\n     * @param filter Optionally filters which radio buttons are included.\n     */\n    async getRadioButtons(filter) {\n        return this.locatorForAll(this._buttonClass.with(filter))();\n    }\n    /**\n     * Checks a radio button in this group.\n     * @param filter An optional filter to apply to the child radio buttons. The first tab matching\n     *     the filter will be selected.\n     */\n    async checkRadioButton(filter) {\n        const radioButtons = await this.getRadioButtons(filter);\n        if (!radioButtons.length) {\n            throw Error(`Could not find radio button matching ${JSON.stringify(filter)}`);\n        }\n        return radioButtons[0].check();\n    }\n    /** Gets the name attribute of the host element. */\n    async _getGroupNameFromHost() {\n        return (await this.host()).getAttribute('name');\n    }\n    /** Gets a list of the name attributes of all child radio buttons. */\n    async _getNamesFromRadioButtons() {\n        const groupNames = [];\n        for (let radio of await this.getRadioButtons()) {\n            const radioName = await radio.getName();\n            if (radioName !== null) {\n                groupNames.push(radioName);\n            }\n        }\n        return groupNames;\n    }\n    /** Checks if the specified radio names are all equal. */\n    _checkRadioNamesInGroupEqual(radioNames) {\n        let groupName = null;\n        for (let radioName of radioNames) {\n            if (groupName === null) {\n                groupName = radioName;\n            }\n            else if (groupName !== radioName) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks if a radio-group harness has the given name. Throws if a radio-group with\n     * matching name could be found but has mismatching radio-button names.\n     */\n    static async _checkRadioGroupName(harness, name) {\n        // Check if there is a radio-group which has the \"name\" attribute set\n        // to the expected group name. It's not possible to always determine\n        // the \"name\" of a radio-group by reading the attribute. This is because\n        // the radio-group does not set the \"name\" as an element attribute if the\n        // \"name\" value is set through a binding.\n        if ((await harness._getGroupNameFromHost()) === name) {\n            return true;\n        }\n        // Check if there is a group with radio-buttons that all have the same\n        // expected name. This implies that the group has the given name. It's\n        // not possible to always determine the name of a radio-group through\n        // the attribute because there is\n        const radioNames = await harness._getNamesFromRadioButtons();\n        if (radioNames.indexOf(name) === -1) {\n            return false;\n        }\n        if (!harness._checkRadioNamesInGroupEqual(radioNames)) {\n            throw Error(`The locator found a radio-group with name \"${name}\", but some ` +\n                `radio-button's within the group have mismatching names, which is invalid.`);\n        }\n        return true;\n    }\n}\n/** Harness for interacting with a standard mat-radio-group in tests. */\nclass MatRadioGroupHarness extends _MatRadioGroupHarnessBase {\n    constructor() {\n        super(...arguments);\n        this._buttonClass = MatRadioButtonHarness;\n    }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatRadioGroupHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which radio group instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatRadioGroupHarness, options).addOption('name', options.name, this._checkRadioGroupName);\n    }\n}\n/** The selector for the host element of a `MatRadioGroup` instance. */\nMatRadioGroupHarness.hostSelector = '.mat-radio-group';\nclass _MatRadioButtonHarnessBase extends ComponentHarness {\n    constructor() {\n        super(...arguments);\n        this._input = this.locatorFor('input');\n    }\n    /** Whether the radio-button is checked. */\n    async isChecked() {\n        const checked = (await this._input()).getProperty('checked');\n        return coerceBooleanProperty(await checked);\n    }\n    /** Whether the radio-button is disabled. */\n    async isDisabled() {\n        const disabled = (await this._input()).getAttribute('disabled');\n        return coerceBooleanProperty(await disabled);\n    }\n    /** Whether the radio-button is required. */\n    async isRequired() {\n        const required = (await this._input()).getAttribute('required');\n        return coerceBooleanProperty(await required);\n    }\n    /** Gets the radio-button's name. */\n    async getName() {\n        return (await this._input()).getAttribute('name');\n    }\n    /** Gets the radio-button's id. */\n    async getId() {\n        return (await this.host()).getProperty('id');\n    }\n    /**\n     * Gets the value of the radio-button. The radio-button value will be converted to a string.\n     *\n     * Note: This means that for radio-button's with an object as a value `[object Object]` is\n     * intentionally returned.\n     */\n    async getValue() {\n        return (await this._input()).getProperty('value');\n    }\n    /** Gets the radio-button's label text. */\n    async getLabelText() {\n        return (await this._textLabel()).text();\n    }\n    /** Focuses the radio-button. */\n    async focus() {\n        return (await this._input()).focus();\n    }\n    /** Blurs the radio-button. */\n    async blur() {\n        return (await this._input()).blur();\n    }\n    /** Whether the radio-button is focused. */\n    async isFocused() {\n        return (await this._input()).isFocused();\n    }\n    /**\n     * Puts the radio-button in a checked state by clicking it if it is currently unchecked,\n     * or doing nothing if it is already checked.\n     */\n    async check() {\n        if (!(await this.isChecked())) {\n            return (await this._clickLabel()).click();\n        }\n    }\n}\n/** Harness for interacting with a standard mat-radio-button in tests. */\nclass MatRadioButtonHarness extends _MatRadioButtonHarnessBase {\n    constructor() {\n        super(...arguments);\n        this._textLabel = this.locatorFor('.mat-radio-label-content');\n        this._clickLabel = this.locatorFor('.mat-radio-label');\n    }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatRadioButtonHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which radio button instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatRadioButtonHarness, options)\n            .addOption('label', options.label, (harness, label) => HarnessPredicate.stringMatches(harness.getLabelText(), label))\n            .addOption('name', options.name, async (harness, name) => (await harness.getName()) === name);\n    }\n}\n/** The selector for the host element of a `MatRadioButton` instance. */\nMatRadioButtonHarness.hostSelector = '.mat-radio-button';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatRadioButtonHarness, MatRadioGroupHarness, _MatRadioButtonHarnessBase, _MatRadioGroupHarnessBase };\n"]},"metadata":{},"sourceType":"module"}